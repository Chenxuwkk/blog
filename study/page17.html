<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.48">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Paxos算法 | Chenxuwkk's Blog</title><meta name="description" content="Chenxuwkk's Blog">
    <link rel="modulepreload" href="/blog/assets/app.b33ca31f.js"><link rel="modulepreload" href="/blog/assets/page17.html.bc75eefa.js"><link rel="modulepreload" href="/blog/assets/page17.html.bda23cdd.js"><link rel="prefetch" href="/blog/assets/about.html.1a741a35.js"><link rel="prefetch" href="/blog/assets/contact.html.03aacf5e.js"><link rel="prefetch" href="/blog/assets/index.html.2e04d9b1.js"><link rel="prefetch" href="/blog/assets/index.html.dc88bf6f.js"><link rel="prefetch" href="/blog/assets/page01.html.6f1784f0.js"><link rel="prefetch" href="/blog/assets/index.html.b2e428a6.js"><link rel="prefetch" href="/blog/assets/page01.html.8647912c.js"><link rel="prefetch" href="/blog/assets/page02.html.2ae31539.js"><link rel="prefetch" href="/blog/assets/page03.html.e30663aa.js"><link rel="prefetch" href="/blog/assets/page04.html.5b5a177e.js"><link rel="prefetch" href="/blog/assets/page05.html.8dc876d3.js"><link rel="prefetch" href="/blog/assets/index.html.1faed378.js"><link rel="prefetch" href="/blog/assets/page00.html.397ec4cb.js"><link rel="prefetch" href="/blog/assets/page01.html.d4c49eb5.js"><link rel="prefetch" href="/blog/assets/page02.html.512e9f97.js"><link rel="prefetch" href="/blog/assets/page03.html.07c7a8d5.js"><link rel="prefetch" href="/blog/assets/page04.html.ea9d586c.js"><link rel="prefetch" href="/blog/assets/page05.html.c54831cd.js"><link rel="prefetch" href="/blog/assets/page06.html.130549e7.js"><link rel="prefetch" href="/blog/assets/page07.html.7c7f84ea.js"><link rel="prefetch" href="/blog/assets/page08.html.e3c59864.js"><link rel="prefetch" href="/blog/assets/page09.html.4785a4a4.js"><link rel="prefetch" href="/blog/assets/page10.html.c6168586.js"><link rel="prefetch" href="/blog/assets/page11.html.ce54a18d.js"><link rel="prefetch" href="/blog/assets/page12.html.1814d2d6.js"><link rel="prefetch" href="/blog/assets/page13.html.3976787d.js"><link rel="prefetch" href="/blog/assets/page14.html.810a54e6.js"><link rel="prefetch" href="/blog/assets/page15.html.3ad37cea.js"><link rel="prefetch" href="/blog/assets/page16.html.c8b15e87.js"><link rel="prefetch" href="/blog/assets/page18.html.8e431832.js"><link rel="prefetch" href="/blog/assets/page19.html.4f7e6a54.js"><link rel="prefetch" href="/blog/assets/page20.html.53b884d3.js"><link rel="prefetch" href="/blog/assets/page21.html.ea7e75ec.js"><link rel="prefetch" href="/blog/assets/page22.html.6a8a8911.js"><link rel="prefetch" href="/blog/assets/page23.html.4da8711b.js"><link rel="prefetch" href="/blog/assets/page24.html.f15f76b8.js"><link rel="prefetch" href="/blog/assets/page25.html.47a43782.js"><link rel="prefetch" href="/blog/assets/index.html.09d3b996.js"><link rel="prefetch" href="/blog/assets/404.html.265028f6.js"><link rel="prefetch" href="/blog/assets/about.html.7c2de1fc.js"><link rel="prefetch" href="/blog/assets/contact.html.af265cd3.js"><link rel="prefetch" href="/blog/assets/index.html.494633a3.js"><link rel="prefetch" href="/blog/assets/index.html.6f6ef67c.js"><link rel="prefetch" href="/blog/assets/page01.html.24477c8b.js"><link rel="prefetch" href="/blog/assets/index.html.06f044c7.js"><link rel="prefetch" href="/blog/assets/page01.html.2c2c82ac.js"><link rel="prefetch" href="/blog/assets/page02.html.519c6760.js"><link rel="prefetch" href="/blog/assets/page03.html.9c782bee.js"><link rel="prefetch" href="/blog/assets/page04.html.01792834.js"><link rel="prefetch" href="/blog/assets/page05.html.ecd56c0e.js"><link rel="prefetch" href="/blog/assets/index.html.0d805a32.js"><link rel="prefetch" href="/blog/assets/page00.html.b5b8a137.js"><link rel="prefetch" href="/blog/assets/page01.html.196f31d8.js"><link rel="prefetch" href="/blog/assets/page02.html.446eff9c.js"><link rel="prefetch" href="/blog/assets/page03.html.265319dc.js"><link rel="prefetch" href="/blog/assets/page04.html.839ac225.js"><link rel="prefetch" href="/blog/assets/page05.html.3ba90d93.js"><link rel="prefetch" href="/blog/assets/page06.html.5ec3bc24.js"><link rel="prefetch" href="/blog/assets/page07.html.9811e105.js"><link rel="prefetch" href="/blog/assets/page08.html.550b989b.js"><link rel="prefetch" href="/blog/assets/page09.html.e59328fe.js"><link rel="prefetch" href="/blog/assets/page10.html.42d79a00.js"><link rel="prefetch" href="/blog/assets/page11.html.07064880.js"><link rel="prefetch" href="/blog/assets/page12.html.29d2532a.js"><link rel="prefetch" href="/blog/assets/page13.html.31c29b64.js"><link rel="prefetch" href="/blog/assets/page14.html.ad9dcffb.js"><link rel="prefetch" href="/blog/assets/page15.html.58f3b33b.js"><link rel="prefetch" href="/blog/assets/page16.html.8841620e.js"><link rel="prefetch" href="/blog/assets/page18.html.467eb0c9.js"><link rel="prefetch" href="/blog/assets/page19.html.55cbf803.js"><link rel="prefetch" href="/blog/assets/page20.html.8b45092f.js"><link rel="prefetch" href="/blog/assets/page21.html.cc2b2ea3.js"><link rel="prefetch" href="/blog/assets/page22.html.d7349c76.js"><link rel="prefetch" href="/blog/assets/page23.html.e468a4f1.js"><link rel="prefetch" href="/blog/assets/page24.html.af7dd849.js"><link rel="prefetch" href="/blog/assets/page25.html.b0d918c5.js"><link rel="prefetch" href="/blog/assets/index.html.1b0cec2a.js"><link rel="prefetch" href="/blog/assets/404.html.b1b48cf0.js"><link rel="prefetch" href="/blog/assets/404.515c5f58.js"><link rel="prefetch" href="/blog/assets/Layout.14a38178.js"><link rel="prefetch" href="/blog/assets/auto.esm.36809f22.js"><link rel="prefetch" href="/blog/assets/index.daae04bf.js"><link rel="prefetch" href="/blog/assets/index.1842ee54.js"><link rel="prefetch" href="/blog/assets/mermaid.esm.min.ee1e0284.js">
    <link rel="stylesheet" href="/blog/assets/style.f6d73350.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><img class="logo" src="/blog/assets/img/logo.png" alt="Chenxuwkk&#39;s Blog"><span class="site-name can-hide">Chenxuwkk&#39;s Blog</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="导航"><span class="title">导航</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="导航"><span class="title">导航</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/blog/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/study/page01" class="" aria-label="学习记录"><!--[--><!--]--> 学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/question/page01" class="" aria-label="疑难问题"><!--[--><!--]--> 疑难问题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/manuscript/page01" class="" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/contact" class="" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/about/" class="" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Chenxuwkk" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="导航"><span class="title">导航</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="导航"><span class="title">导航</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/blog/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/study/page01" class="" aria-label="学习记录"><!--[--><!--]--> 学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/question/page01" class="" aria-label="疑难问题"><!--[--><!--]--> 疑难问题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/manuscript/page01" class="" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/contact" class="" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/about/" class="" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Chenxuwkk" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/blog/guide/" class="sidebar-item sidebar-heading" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">学习记录 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/study/page01.html" class="sidebar-item" aria-label="Vuepress部署"><!--[--><!--]--> Vuepress部署 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page03.html" class="sidebar-item" aria-label="Linux 命令"><!--[--><!--]--> Linux 命令 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page02.html" class="sidebar-item" aria-label="C语言预处理"><!--[--><!--]--> C语言预处理 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page04.html" class="sidebar-item" aria-label="C语言位运算"><!--[--><!--]--> C语言位运算 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page05.html" class="sidebar-item" aria-label="C语言指针"><!--[--><!--]--> C语言指针 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page07.html" class="sidebar-item" aria-label="C语言动态内存"><!--[--><!--]--> C语言动态内存 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page08.html" class="sidebar-item" aria-label="C语言字符串处理"><!--[--><!--]--> C语言字符串处理 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page09.html" class="sidebar-item" aria-label="C语言结构体详解"><!--[--><!--]--> C语言结构体详解 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page10.html" class="sidebar-item" aria-label="C语言链表"><!--[--><!--]--> C语言链表 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page21.html" class="sidebar-item" aria-label="C++对C语言的加强"><!--[--><!--]--> C++对C语言的加强 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page06.html" class="sidebar-item" aria-label="Markdown高级技巧"><!--[--><!--]--> Markdown高级技巧 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page11.html" class="sidebar-item" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page12.html" class="sidebar-item" aria-label="C51"><!--[--><!--]--> C51 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page13.html" class="sidebar-item" aria-label="STM32"><!--[--><!--]--> STM32 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page14.html" class="sidebar-item" aria-label="嵌入式小记"><!--[--><!--]--> 嵌入式小记 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page15.html" class="sidebar-item" aria-label="IMRD"><!--[--><!--]--> IMRD <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="Paxos算法"><!--[--><!--]--> Paxos算法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page17.html#一致性分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="一致性分类"><!--[--><!--]--> 一致性分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#一致性" class="router-link-active router-link-exact-active sidebar-item" aria-label="一致性"><!--[--><!--]--> 一致性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page17.html#定义" class="router-link-active router-link-exact-active sidebar-item" aria-label="定义"><!--[--><!--]--> 定义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#要求" class="router-link-active router-link-exact-active sidebar-item" aria-label="要求"><!--[--><!--]--> 要求 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/study/page17.html#共识性" class="router-link-active router-link-exact-active sidebar-item" aria-label="共识性"><!--[--><!--]--> 共识性 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page17.html#分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="分类"><!--[--><!--]--> 分类 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/study/page17.html#共识性与一致性的区别-consistency-vs-consensus" class="router-link-active router-link-exact-active sidebar-item" aria-label="共识性与一致性的区别（Consistency vs. Consensus）"><!--[--><!--]--> 共识性与一致性的区别（Consistency vs. Consensus） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#一致性和共识的联系" class="router-link-active router-link-exact-active sidebar-item" aria-label="一致性和共识的联系"><!--[--><!--]--> 一致性和共识的联系 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#paxos问题假设" class="router-link-active router-link-exact-active sidebar-item" aria-label="Paxos问题假设"><!--[--><!--]--> Paxos问题假设 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#算法的提出与证明" class="router-link-active router-link-exact-active sidebar-item" aria-label="算法的提出与证明"><!--[--><!--]--> 算法的提出与证明 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#state-mechine-replication" class="router-link-active router-link-exact-active sidebar-item" aria-label="state mechine replication"><!--[--><!--]--> state mechine replication <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page17.html#_1-1-safty-liveness-fault-tolerance" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 safty &amp; liveness &amp; fault tolerance"><!--[--><!--]--> 1.1 safty &amp; liveness &amp; fault tolerance <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page17.html#_1-2-consensus" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 consensus"><!--[--><!--]--> 1.2 consensus <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/study/page17.html#_2-paxos与flp" class="router-link-active router-link-exact-active sidebar-item" aria-label="2 paxos与FLP"><!--[--><!--]--> 2 paxos与FLP <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/blog/study/page18.html" class="sidebar-item" aria-label="STL"><!--[--><!--]--> STL <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page19.html" class="sidebar-item" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page16.html" class="sidebar-item" aria-label="Leetcode"><!--[--><!--]--> Leetcode <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page20.html" class="sidebar-item" aria-label="剑指Offer"><!--[--><!--]--> 剑指Offer <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page22.html" class="sidebar-item" aria-label="剑指Offer II"><!--[--><!--]--> 剑指Offer II <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page23.html" class="sidebar-item" aria-label="二分专项"><!--[--><!--]--> 二分专项 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page24.html" class="sidebar-item" aria-label="动态规划专项"><!--[--><!--]--> 动态规划专项 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page25.html" class="sidebar-item" aria-label="SQL"><!--[--><!--]--> SQL <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">疑难问题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/blog/question/page01.html" class="sidebar-item" aria-label="Git同步 😄"><!--[--><!--]--> Git同步 😄 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page02.html" class="sidebar-item" aria-label="Ubantu内存重新分配（Vmware） 🍎"><!--[--><!--]--> Ubantu内存重新分配（Vmware） 🍎 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page03.html" class="sidebar-item" aria-label="一个个小坑（Vue） 💢"><!--[--><!--]--> 一个个小坑（Vue） 💢 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page04.html" class="sidebar-item" aria-label="VSCode编译C\C++"><!--[--><!--]--> VSCode编译C\C++ <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page05.html" class="sidebar-item" aria-label="代码复现问题"><!--[--><!--]--> 代码复现问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/blog/manuscript/page01" class="sidebar-item sidebar-heading" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a><!----></li><li><a href="/blog/contact" class="sidebar-item sidebar-heading collapsible" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a><!----></li><li><a href="/blog/about" class="sidebar-item sidebar-heading" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="paxos算法" tabindex="-1"><a class="header-anchor" href="#paxos算法" aria-hidden="true">#</a> Paxos算法</h1><hr><nav class="table-of-contents"><ul><li><a aria-current="page" href="/blog/study/page17.html#一致性分类" class="router-link-active router-link-exact-active">一致性分类</a></li><li><a aria-current="page" href="/blog/study/page17.html#一致性" class="router-link-active router-link-exact-active">一致性</a><ul><li><a aria-current="page" href="/blog/study/page17.html#定义" class="router-link-active router-link-exact-active">定义</a></li><li><a aria-current="page" href="/blog/study/page17.html#要求" class="router-link-active router-link-exact-active">要求</a></li></ul></li><li><a aria-current="page" href="/blog/study/page17.html#共识性" class="router-link-active router-link-exact-active">共识性</a><ul><li><a aria-current="page" href="/blog/study/page17.html#分类" class="router-link-active router-link-exact-active">分类</a></li></ul></li><li><a aria-current="page" href="/blog/study/page17.html#共识性与一致性的区别-consistency-vs-consensus" class="router-link-active router-link-exact-active">共识性与一致性的区别（Consistency vs. Consensus）</a></li><li><a aria-current="page" href="/blog/study/page17.html#一致性和共识的联系" class="router-link-active router-link-exact-active">一致性和共识的联系</a></li><li><a aria-current="page" href="/blog/study/page17.html#小结" class="router-link-active router-link-exact-active">小结</a></li><li><a aria-current="page" href="/blog/study/page17.html#paxos问题假设" class="router-link-active router-link-exact-active">Paxos问题假设</a></li><li><a aria-current="page" href="/blog/study/page17.html#算法的提出与证明" class="router-link-active router-link-exact-active">算法的提出与证明</a></li><li><a aria-current="page" href="/blog/study/page17.html#state-mechine-replication" class="router-link-active router-link-exact-active">state mechine replication</a><ul><li><a aria-current="page" href="/blog/study/page17.html#_1-1-safty-liveness-fault-tolerance" class="router-link-active router-link-exact-active">1.1 safty &amp; liveness &amp; fault tolerance</a></li><li><a aria-current="page" href="/blog/study/page17.html#_1-2-consensus" class="router-link-active router-link-exact-active">1.2 consensus</a></li></ul></li><li><a aria-current="page" href="/blog/study/page17.html#_2-paxos与flp" class="router-link-active router-link-exact-active">2 paxos与FLP</a></li></ul></nav><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><h2 id="一致性分类" tabindex="-1"><a class="header-anchor" href="#一致性分类" aria-hidden="true">#</a> 一致性分类</h2><ul><li><p>弱一致性</p><ul><li><p>最终一致性（你往数据库中写，系统不保证你会立马读到，但最终会读到）</p><ul><li><p>DNS（Domain Name System）</p></li><li><p>Gossip（Cassandra的通信协议）<strong>保证可靠性？</strong></p><p>我们不保证可靠性！就像新冠一样，我传播了之后它就一直传播，直到把所有人都感染。</p></li></ul></li></ul></li><li><p>强一致性</p><ul><li>同步 <ul><li>Paxos（每个paxos实例用于存储一个值）</li><li>Raft</li><li>ZAB</li></ul></li></ul></li></ul><p>提出问题，数据必须是安全的，鸡蛋不能放在同一个篮子里，如果有个篮子坏了这个系统必须还能用，需要具有容错能力。</p><p>大多数的解决方案是 state machine replication（同步log）</p><p>这里举个例子：三个人分别只允许呆在不同的三个城市，他们手上有一张纸和一支笔，他们可以在纸上写下任何内容，但是，当他们停下他们的笔之后，我们希望三个人最后写下的内容都是一样的。</p><p>这个就是最朴素的Paxos尝试解决的问题，确定一个值。暂时千万别去想更多的东西，聚焦在确定一个值这么一个看似非常简单的事情身上。</p><p><strong>前提假设</strong>：<strong>我们的问题范围，非拜占庭故障，唯一的故障就是节点奔崩溃</strong></p><p><strong>Paxos本身就是利用消息传递方式解决一致性问题的，所以它的假定是信道必须可靠，这里的可靠，主要指消息不会被篡改。消息丢失是允许的。</strong></p><p>Paxos有很多版本</p><ul><li>Basic Paxos <ul><li>活锁问题（random延时）</li><li>难实现、效率低（2轮RPC--远程过程调用协议）、活锁</li></ul></li><li>Multi Paxos <ul><li>引入了leader：唯一的proposer，所有请求都要进过他</li></ul></li><li>Fast Paxos</li></ul><p><strong>应用场景</strong> ：paxos现在大多是应用于replication的一致性，用来实现一个多节点一致的日志</p><h2 id="一致性" tabindex="-1"><a class="header-anchor" href="#一致性" aria-hidden="true">#</a> <strong>一致性</strong></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>在分布式系统中，运行着多个相互关联的服务节点。</p><p><strong>一致性是指</strong>分布式系统中的多个服务节点，给定一系列的操作，在约定协议的保障下，使它们<strong>对外界呈现的状态是一致的。<strong>换句话说</strong>，也就是</strong>保证集群中所有服务节点中的<strong>数据完全相同</strong>并且能够<strong>对某个提案（Proposal）达成一致</strong>。多个节点不能产生矛盾。</p><h3 id="要求" tabindex="-1"><a class="header-anchor" href="#要求" aria-hidden="true">#</a> 要求</h3><ul><li>首先，达成一致的结果在<strong>有限的时间</strong>内完成。简称为<strong>有限性</strong>。</li><li>其次，不同节点最终完成决略的结果是相同的。<strong>约同性</strong>。</li><li>决策的结果必须是系统中某个节点提出来的。<strong>合法性</strong>。</li></ul><p>也就是说，在分布式系统中，如果一个由节点提出的提案，能够用在有限的时间内，达到一致性的结果，我们就说该提案达到了一致性。</p><h2 id="共识性" tabindex="-1"><a class="header-anchor" href="#共识性" aria-hidden="true">#</a> <strong>共识性</strong></h2><p>###　<strong>定义</strong></p><p><strong>共识性</strong>描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。 在实践中，要保障系统满足不同程度的一致性，核心过程往往需要通过共识算法来达成。</p><p>共识算法解决的是对某个提案（proposal）大家达成一致意见的过程。提案的含义在分布式系统中十分宽泛，如多个事件发生的顺序、某个键对应的值、谁是领导……等等。可以认为任何可以达成一致的信息都是一个提案。对于分布式系统来讲，各个节点通常都是相同的确定性状态机模型（又称为状态机复制问题，state-machine replication），从相同初始状态开始接收相同顺序的指令，则可以保证相同的结果状态。因此，系统中多个节点最关键的是对多个事件的顺序进行共识，即排序。</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>根据解决的是非拜占庭的普通错误情况还是拜占庭错误情况，共识算法可以分为Crash Fault Tolerance（CFT）类算法和Byzantine Fault Tolerance（BFT）类算法。</p><p>一般地，把出现故障( crash 或 fail-stop，即不响应)但不会伪造信息的情况称为“非拜占庭错误”( non-byzantine fault)或“故障错误”( Crash Fault)</p><p>伪造信息恶意响应的情况称为“拜占庭错误”( Byzantine Fault)，对应节点为拜占庭节点。</p><p>处理非拜占庭错误的算法有：paxos、raft和其变种</p><p>处理拜占庭错误算法有：pbft、pow算法</p><h4 id="非拜占庭容错类算法" tabindex="-1"><a class="header-anchor" href="#非拜占庭容错类算法" aria-hidden="true">#</a> <strong>非拜占庭容错类算法</strong></h4><p>针对常见的非拜占庭错误的情况，已经存在一些经典的解决算法，包括Paxos、Raft及其变种等。这类容错算法往往性能比较好，处理较快，容忍不超过一半的故障节点。</p><h4 id="拜占庭容错类算法" tabindex="-1"><a class="header-anchor" href="#拜占庭容错类算法" aria-hidden="true">#</a> <strong>拜占庭容错类算法</strong></h4><p><strong>拜占庭故障</strong>（也叫做<strong>交互一致性</strong>，<strong>源一致性</strong>，<strong>错误雪崩</strong>，<strong>拜占庭协议问题</strong>，<strong>拜占庭将领问题</strong>和<strong>拜占庭故障</strong>）是一个计算机系统的状态，特别是**「分布式计算」**系统中，其中的组件可能会故障，并且在组件故障时可能发生故障信息。</p><p>拜占庭容错( <strong>BFT</strong> ) 就是这种状态下可靠的**「容错计算机系统」**。</p><p>拜占庭容错的目标是能够预防系统组件的故障，无论系统的其他组件是否有阻止它们之间达成一致的症状，这种情况下，系统的正常运转需要达成这样的一致。</p><p>拜占庭故障被认为是故障模式中最普遍和最困难的故障类别。所谓的**「失败停止故障模式」<strong>占据了故障范围内的最简单的一部分。失败停止故障模式只意味着唯一的故障方式是</strong>节点崩溃**，被其他节点检测到。拜占庭故障意味着没有限制，即故障节点可以生成任意数据，包括使其看起来像一个正常运行的节点数据。</p><p>因此，拜占庭故障会混淆故障检测系统，这使得容错变得困难。</p><p>拜占庭容错<strong>只关心广播的正确性</strong>，即当一个组件向其他组件广播一个一致的值（即向其他组件发送相同的值）时，它们都收到完全相同的值。或者在如果广播的值不一致，其他组件就共同的值达成一致。</p><p>这里强调一点：<strong>这种容错不包括值本身的正确性</strong>。例如，一个恶意的组件故意发送错误值，但向所有组件发送一致的相同值（其实这是错误值），这种情况不会被拜占庭容错方案捕获。</p><p>对于要能容忍拜占庭错误的情况，一般包括PBFT（Practical Byzantine Fault Tolerance）为代表的确定性系列算法、PoW为代表的概率算法等。对于确定性算法，一旦达成对某个结果的共识就不可逆转，即共识是最终结果；而对于概率类算法，共识结果则是临时的，随着时间推移或某种强化，共识结果被推翻的概率越来越小，成为事实上的最终结果。</p><p>**拜占庭类容错算法往往性能较差，容忍不超过1/3的故障节点。**此外，XFT（Cross Fault Tolerance）等最近提出的改进算法可以提供类似CFT的处理响应速度，并能在大多数节点正常工作时提供BFT保障。</p><p>引用来源：<a href="https://zhuanlan.zhihu.com/p/35596768" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/35596768<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="共识性与一致性的区别-consistency-vs-consensus" tabindex="-1"><a class="header-anchor" href="#共识性与一致性的区别-consistency-vs-consensus" aria-hidden="true">#</a> <strong>共识性与一致性的区别（Consistency vs. Consensus）</strong></h2><p><strong>一致性</strong>往往指分布式系统中多个副本<strong>对外呈现的数据的状态</strong>。如前面提到的顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p><strong>共识性</strong>则描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。</p><p>因此，<strong>一致性描述的是结果状态</strong>，<strong>共识则是一种手段</strong>。<strong>达成某种共识并不意味着就保障了一致性（这里的一致性指强一致性）。只能说共识机制，能够实现某种程度上的一致性。</strong></p><p>实践中，要保障系统满足不同程度的一致性，核心过程往往需要通过共识算法来达成。</p><p><strong>“一致性 = 符合特定规则的静态状态（静态）”</strong></p><p><strong>“共识 = 状态间变换规则的选举过程（动态）”</strong></p><p><img src="https://m.360buyimg.com/babel/jfs/t1/7743/14/17345/88070/6298a521E95f002a0/4c3994a8789c9b81.jpg" alt="9072280-b2b181af1b020c8a.jpg"></p><h2 id="一致性和共识的联系" tabindex="-1"><a class="header-anchor" href="#一致性和共识的联系" aria-hidden="true">#</a> <strong>一致性和共识的联系</strong></h2><p><img src="https://m.360buyimg.com/babel/jfs/t1/7792/34/16754/84978/6298a521E4f75ef6d/c559b22abe6c6ff7.jpg" alt="9072280-28d9e054b252e5b9.jpg"></p><p>再借助<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fraft.github.io%2Fraft.pdf" target="_blank" rel="noopener noreferrer">Raft<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>来说明一下，在Raft算法中，作者将一致性问题看成系统中进程间（在不同机器上）一个状态机同步问题，为保证每个机器上的进程具有一致性（即状态改变的过程一样），作者使用了Raft这个共识算法来保证在每个进程初始状态相同的情况下，每个进程的下一个操作（状态改变操作）相同，这样就能保证所有进程的状态机的改变过程是一样的，即系统中的进程最终会达成一致状态。</p><p>可以说，<strong>Consistency是系统中需要保证的一个属性（即“Allowed ways”），而Consensus算法是实现Consistency的一种手段（主要是最终一致性）。</strong></p><p>引用来源：<a href="https://www.jianshu.com/p/98f94482c9f1" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/98f94482c9f1<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>举一个形象的例子：假如有一个立法委员会，要决议通过一个法律，并向全国人民发布法律，最后在一定时刻法律生效。</p><p>上述过程涉及法律的生成和法律生效两个子过程。其中在法律生成子过程中需要利用<strong>共识算法</strong>，各议员相互协商最终达成一致的意见，生成法律；在法律生效过程中，<strong>一致性算法</strong>描述了为了在法律颁布后能在有效时间内使得全国各地法律按照一定的顺序生效，而需要遵守的相关规则和规定。</p><p>引用来源：<a href="https://www.jianshu.com/p/484e4599b59a" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/484e4599b59a<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="paxos问题假设" tabindex="-1"><a class="header-anchor" href="#paxos问题假设" aria-hidden="true">#</a> Paxos问题假设</h2><p>Paxos算法是<strong>莱斯利·兰伯特</strong>（英语：Leslie Lamport，LaTeX中的“La”）于1990年提出的一种基于消息传递且具有高度容错特性的共识（consensus）算法。</p><h4 id="需要注意的是-paxos常被误称为-一致性算法-。但是-一致性-consistency-和-共识-consensus-并不是同一个概念。paxos是一个共识-consensus-算法。-ppt要写" tabindex="-1"><a class="header-anchor" href="#需要注意的是-paxos常被误称为-一致性算法-。但是-一致性-consistency-和-共识-consensus-并不是同一个概念。paxos是一个共识-consensus-算法。-ppt要写" aria-hidden="true">#</a> 需要注意的是，Paxos常被误称为“一致性算法”。但是“一致性（consistency）”和“共识（consensus）” 并不是同一个概念。Paxos是一个共识（consensus）算法。（<strong>PPT要写</strong>）</h4><p>Paxos 算法解决的问题是在一个可能发生前述异常（即非拜占庭问题）的分布式系统中，如何对某个值的看法相同，<strong>保证无论发生以上任何异常，都不会破坏决议的共识机制。</strong></p><p>为描述Paxos算法，Lamport虚拟了一个叫做Paxos的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。但是这里假设没有拜占庭将军问题（虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息）</p><p>只要等待足够的时间，消息就会被传到。另外，Paxos岛上的议员是不会反对其他议员提出的决议的。</p><p>对应于分布式系统，<strong>议员对应于各个节点</strong>，<strong>制定的法律对应于系统的状态</strong>。各个节点需要进入一个一致的状态，例如在独立Cache的对称多处理器系统中，各个处理器读内存的某个字节时，必须读到同样的一个值，否则系统就违背了一致性的要求。<strong>一致性要求对应于法律条文只能有一个版本</strong>。议员和服务员的不确定性对应于节点和消息传递通道的不可靠性。</p><h2 id="算法的提出与证明" tabindex="-1"><a class="header-anchor" href="#算法的提出与证明" aria-hidden="true">#</a> 算法的提出与证明</h2><p>首先将议员的角色分为 proposers，acceptors，和 learners（允许身兼数职）。</p><p>client 系统外部角色，请求发起者，普通民众</p><p>proposers 接收client的请求，向集群提出提案，提案信息包括提案编号和提议的 value；</p><p>acceptor 收到提案后可以接受（accept）提案，若提案获得法定人数（Quorum，一般为majority多数派）的 acceptors 的接受，则称该提案被批准（chosen）；</p><p>learners 只能“学习”被批准的提案，对应数据库备份。</p><p>划分角色后，就可以更精确的定义问题：</p><ol><li>决议（value）只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案（proposal）”）提案--》决议</li><li>在一次 Paxos 算法的执行实例中，只批准（chosen）一个 value</li><li>learners 只能获得被批准（chosen）的 value</li></ol><p><strong>我是这么理解Paxos算法的</strong></p><p>同学聚会出去玩</p><p>Client: 提出问题 咱们下面要去哪里玩呢 Propose： 鬼点子王 A B ... 开始发表意见/提案（ID自增长） Acceptor： 嗯嗯,不错,这个也不错呢,这个也不错, 点子的接受者,但是接受的方式很简单 谁的点子是最新提出的就听投谁的（事务ID / 提案ID） Learner：没有主见的家伙,很随意,什么都是随便阿随便,然后埋头玩手机的那群人,只等着他们讨论结束跟着他们混</p><p>提案通过很简单 过半就行 A开始提案A1 - 先去吃饭吧, 然后Acceptosr开始投票,嗯嗯.不错不错,可以可以,,,还没有过半通过 这时候 B又开始新提案B2 去看电影吧 然后Acceptor又开始新一轮投票 因为B提案ID比A的大 所以大家都比较接受B的题按</p><p>​ 如果投票过半那就直接按B提案大家一起去看电影 然后跟旁边的几个玩手机的说 咱们去看电影吧 然后大家就一起去看电影了 ​ 如果投票没过半A那家伙不甘心肚子饿了就是想去吃饭又提出提案A3 大家又开始投票 ​ B也不甘示弱也提案B4 这样两个人没完没了的 大家都被弄晕了 ​ ​ 冲突要打架了,所以才有了老师后面说的等个时间 ​ A提案的时候 B也想提案不过得先等个10s 要是10S内大家都过半A的提议 那就听A的去吃饭 如果10S还没过半那就执行B的提案</p><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><p>实际paxos算法中采用的就是时间戳+id</p><p><strong>阶段1</strong></p><ul><li>P1A：Prepare <ul><li>在Prepare阶段，一个Proposer会创建一个Prepare消息，每个Prepare消息都有唯一的提案编号n。（<strong>这个阶段没有传送value</strong>）</li><li>n并不是将要提案的内容，而只是一个唯一的编号，用来标志这个Prepare的消息。</li><li>n必须比该Proposer之前用过的所有编号都大，一般来说我们可以以数字递增的方式来实现这个编号。</li><li>接下来Proposer会把该编号发送给Acceptors，只有大多数Acceptors接收到Proposer发来的消息，该消息才算是发送成功。</li></ul></li><li>P1B：Promise 所有的Acceptors都在等待从Proposers发过来的Prepare消息。当一个Acceptor收到从Proposer发过来的Prepare消息时候，会有两种情况： <ul><li>该消息中的n是Acceptor所有收到的Prepare消息中最大的一个，那么该Acceptor必须返回一个Promise消息给Proposer，告诉它后面所有小于n的消息我都会忽略掉。如果该Acceptor在过去的某个时间已经确认了某个消息，那么它必须返回那个消息的proposal number m 和 accepted value w （m，w）。如果该Acceptor在过去并没有确认过任何消息，那么会返回NULL。</li><li>如果Prepare消息中的n小于该Acceptor之前接收到的消息，那么该消息会被Acceptor忽略（为了优化也可以返回一个拒绝消息给Proposer，告诉它不要再发小于n的消息给我了）。</li></ul></li></ul><p><strong>阶段2</strong></p><ul><li>P2A：Accept 如果一个Proposer从Acceptors接收到了足够多的Promises（&gt;n/2），这表示该Proposer可以开始下一个Accept请求的阶段了，在Accept阶段，Proposer需要设置一个值，然后向Acceptors发送Accept请求。 在阶段1B我们讲到了，如果Acceptor之前确认过消息，那么会把该消息编号和消息的值（m，w）返回给Proposer， Proposer收到多个Acceptors返回过来的消息之后，会从中选择编号最大的一个消息所对应的值z，并把他作为Accept请求的值（n，z）发给Acceptor。如果所有的Acceptors都没有确认过消息，那么Proposer可以自主选择要确认的值z。</li><li>P2b: Accepted 当Acceptor接收到了Proposer的确认消息请求（n，z），如果该Acceptor在阶段1b的时候没有promise只接收&gt;n的消息，那么该（n，z）消息就必须被Acceptor确认。 当（n，z）消息被Acceptor确认时，Acceptor会发送一个Accepted（n，z）消息给Proposer 和所有的Learner。当然在大部分情况下Proposer和Learner这两个角色可以合并。 如果该Acceptor在阶段1b的时候promise只接收&gt;n的消息，那么该确认请求消息会被拒绝或者忽略。 按照以上的逻辑就会出现在一个轮次中，Acceptor 确认多次消息的情况。什么情况下才会出现这样的情况呢？ 我们举个例子： Acceptor 收到Accept（n，z），然后返回了Accepted（n，z），接下来该Acceptor 又收到了Prepare（n+1)请求，按照阶段1B的原则，Acceptor会 Promise （n+1，z），然后Acceptor 收到Accept（n+1，z），最后返回Accepted（n+1，z）。大家可以看到尽管Acceptor 确认了多次请求，但是最终会确保确认的值是保持一致的。</li></ul><p>引用来源：<a href="https://www.jianshu.com/p/ecc6168b33a7" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/ecc6168b33a7<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>下图中，propose_B被拒绝以后会提高自己的ID，继续提交，达到共识</p><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><div class="md-enhance-mermaid loading"><svg xmlns="http://www.w3.org/2000/svg" class="icon loading-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="loading icon"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="0s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="0s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.333s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.333s"></animate></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" strokewidth="2"><animate attributename="r" repeatcount="indefinite" dur="1s" values="0;40" keytimes="0;1" keysplines="0 0.2 0.8 1" calcmode="spline" begin="-0.667s"></animate><animate attributename="opacity" repeatcount="indefinite" dur="1s" values="1;0" keytimes="0;1" keysplines="0.2 0 0.8 1" calcmode="spline" begin="-0.667s"></animate></circle></svg></div><p><strong>工程应用</strong>：有一个分布式集群，里面有很多server(服务器)，每个服务器中包含自己的数据库（learner）、日志(log)。</p><p>每条日志有自己的LogID。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1 a=1
2 b=3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个client向server发出一个请求时，例如client 要增加一条日志LogID为3，内容为insert c=1</p><p>这个时候server化身proposer，先通过时间戳+ID的方式（根据paxos协议的要求，proposalID要满足全局唯一和递增序，即对同一个server来说后产生的proposalID一定大于之前产生的），申请到<strong>ProposalID</strong></p><p><strong>Prepare阶段</strong></p><p>Proposer准备好proposalID后，将proposalID作为 “提案（proposal）”发送给所有的acceptor（server）。</p><p>根据Paxos协议P1b的约束，这个阶段发送的proposal并不需要携带日志内容，而只需要发送proposalID。</p><p>Acceptor收到proposal后，根据Paxos协议P1b判断是否要“回应（response）”：只有在这个Paxos Instance内（即针对这个logID）没有response过proposalID大于等于当前proposal的，并且也没有“接受（accept）”过proposalID大于当前proposal的，才可以response，并承诺不再accept那些proposalID小于当前proposal的。</p><p>如果已经accept过proposal，那么连同proposalID最大的日志内容一同response。</p><p><strong>Accept请求阶段</strong></p><p>Proposer收集到majority的response后，来决定后续是否将要发出的“accept请求（accept request）”，判断如果majority的response中的日志内容都为空，那么可以向所有acceptor发出accept request并携带上当前日志内容；而如果有任意的response中的日志内容有效，那么说明当前logID已经别其他日志占用，且其他日志可能已经在majority上持久化，因此为了保证log的一致性，将把自己原本的insert c=1 替换为response的内容，保证了共识（后者需要认同前者）</p><p>Proposer：</p><p>Acceptor：</p><p><strong>P1: Acceptor必须接受他接收到的第一个提案。</strong></p><p><strong>P2: 一个提案被选中需要过半数的Acceptor接受。</strong></p><p><strong>P3：当编号K0、Value为V0的提案(即[K0,V0])被过半的Acceptor接受后，今后（同一个Paxos或称一个Round中）所有比K0更高编号且被Acceptor接受的提案，其Value值也必须为V0。</strong></p><p><strong>P4：只有Acceptor没有接受过提案Proposer才能采用自己的Value，否者Proposer的Value提案为Acceptor中编号最大的Proposer Value；</strong></p><p><strong>个人理解</strong></p><p>总的来说一句话概括：谁先被accepted（<strong>注意这里不是说谁先被promise</strong>），后面的人都要将先前的accepted的value当作自己的value，这样达成共识。</p><p><strong>对于acceptor来说：</strong></p><ul><li>我见到的第一个议案（proposal）我一定会给他一个承诺(promise)的。</li><li>我只喜欢编号最大的议案，其他的都是垃圾会被我丢掉。</li><li>如果有比我现在批准(accepted)的编号大的议案拿给我，我非常喜欢并且承诺(promise)他，同时我也会诚实的告诉他我已经批准过议案的内容(value)。</li><li>议案只有经过我们法定人数的承诺(promise)、批准(accepted)两步才能被发行(存入learner，形成共识)。</li></ul><p><strong>对于Proposer来说：</strong></p><ul><li>我每准备(prepare)提一个议案都会提交一个自增的议案ID。</li><li>只有当法定人数的acceptor都承诺(promise)要支持我，我才敢提出我的议案内容(value)去寻求批准(accept)。</li><li>反之我没有收到大多数人的投票，那我一定收到了acceptor告诉我的其他人的议案内容。</li><li>如果前面已经有人的议案被批准(accepted)，那我为了世界和平我选择支持他，将我的议案内容改为和他一样的(value)。</li><li>如果我的议案被丢进垃圾桶里了，我会增加我的议案ID，继续上报。</li><li>我的提议都是人民(client)的意见，即便是我挂了，还有其他人(proposer)听取人民(client)的意见。</li></ul><h2 id="state-mechine-replication" tabindex="-1"><a class="header-anchor" href="#state-mechine-replication" aria-hidden="true">#</a> state mechine replication</h2><p><a href="https://segmentfault.com/a/1190000004033730" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000004033730<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/bluecloudmatrix/article/details/40582143" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/bluecloudmatrix/article/details/40582143<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>有限状态机是一种概念性机器，它能采取某种操作来响应一个外部事件。具体采取的操作不仅能取决于接收到的事件，还能取决于各个事件的相对发生顺序。之所以能 做到这一点，是因为机器能跟踪一个内部状态，它会在收到事件后进行更新。为一个事件而响应的行动不仅取决于事件本身，还取决于机器的内部状态。另外，采取 的行动还会决定并更新机器的状态。这样一来，任何逻辑都可<a href="https://baike.baidu.com/item/%E5%BB%BA%E6%A8%A1" target="_blank" rel="noopener noreferrer">建模<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>成一系列事件/状态组合。</p><p>[2] 状态机可归纳为4个要素，即现态、条件、动作、次态。这样的归纳，主要是出于对状态机的内在因果关系的考虑。“现态”和“条件”是因，“动作”和“次态”是果。详解如下：</p><ol><li>现态：是指当前所处的状态。</li><li>条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li><li>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li><li>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ol><p>状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型。说白了，一般就是指一张状态转换图。例如，根据自动门的运行规则，我们可以抽象出下面这么一个图。</p><p><img src="https://m.360buyimg.com/babel/jfs/t1/216296/37/18995/30654/6298a548E7645ad9d/117baa1a9e514318.jpg" alt="v2-6592767bc90a8c71b2743e8fedaa6b00_720w.jpg"></p><p>自动门有两个状态，open 和 closed ，closed 状态下，如果读取开门信号，那么状态就会切换为 open 。open 状态下如果读取关门信号，状态就会切换为 closed 。</p><p>状态机的全称是有限状态自动机，自动两个字也是包含重要含义的。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。例如对于自动门，给定初始状态 closed ，给定输入“开门”，那么下一个状态时可以运算出来的。</p><p>这样状态机的基本定义我们就介绍完毕了。重复一下：状态机是有限状态自动机的简称，是现实事物运行规则抽象而成的一个数学模型。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | 
   X--------&gt;|          |  |  |       |  |  Request
   |         X---------&gt;|-&gt;|-&gt;|       |  |  Prepare(N)
   |         |&lt;---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X---------&gt;|-&gt;|-&gt;|       |  |  Accept!(N,I,V)
   |         |&lt;---------X--X--X------&gt;|-&gt;|  Accepted(N,I,V)
   |&lt;---------------------------------X--X  Response
   |         |          |  |  |       |  |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Client   Proposer      Acceptor     Learner
   |       |           |  |  |       |  | 
   X------&gt;|           |  |  |       |  |  Request
   |       X----------&gt;|-&gt;|-&gt;|       |  |  Prepare(1)
   |       |&lt;----------X--X--X       |  |  Promise(1,0,{null,null,null})
   |       !           |  |  |       |  |    
   |          |        |  |  |       |  |  Prepare(2)
   |          x-------&gt;|-&gt;|-&gt;|       |  |  Promise(2,0,{null,null,null})
   |          |&lt;-------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |       |  |        |  |  |       |  | 
   |       |  |        |  |  |       |  | 
   |       X----------&gt;|-&gt;|-&gt;|       |  |  Prepare(2)
   |       |&lt;----------X--X--X       |  |  Nack(2)
   |       |  |        |  |  |       |  |    
   |       X----------&gt;|-&gt;|-&gt;|       |  |  Prepare(3)
   |       |&lt;----------X--X--X       |  |  Promise(3,0,{null,null,null})
   |       |  |        |  |  |       |  |       
   |       |  x-------&gt;|-&gt;|-&gt;|       |  |  Accept!(2,0,V)
   |       |  |&lt;-------X--X--X       |  |  Nack(3)
   |       |  |        |  |  |       |  |       
   |       |  x-------&gt;|-&gt;|-&gt;|       |  |  Prepare(4)
   |       |  |&lt;-------X--X--X       |  |  Promise(4,0,{null,null,null})
   |       |  |        |  |  |       |  |       
   |       X----------&gt;|-&gt;|-&gt;|       |  |  Accept!(3,0,V)
   |       |&lt;----------X--X--X       |  |  Nack(4)
   |       |  |        |  |  |       |  |       
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="paxos为什么可以" tabindex="-1"><a class="header-anchor" href="#paxos为什么可以" aria-hidden="true">#</a> Paxos为什么可以？</h1><p>此时我们会马上想到，Paxos算法的场景比FLP的系统模型还要松散，除了异步通信，Paxos允许消息丢失（通信不健壮），但Paxos却被认为是最牛的一致性算法，其作者Lamport也获得2014年的图灵奖，这又是为什么？ 其实仔细回忆Paxos论文会发现，Paxos中存在活锁，理论上的活锁会导致Paxos算法无法满足Termination属性，也就不算一个正确的一致性算法。Lamport在自己的论文中也提到“FLP结果表明，不存在完全满足一致性的异步算法...&quot;，因此他建议通过Leader来代替Paxos中的Proposer，而Leader则通过随机或其他方式来选定（Paxos中假如随机过程会极大降低FLP发生的概率）。也就是说Paxos算法其实也不算理论上完全正确的，只是在工程实现中避免了一些理论上存在的问题。</p><p>（Termination（终止性）非失败进程最终可以做出选择）</p><p>configuration （状态的集合）中的每一个变量变化，Paxos只讨论某一个变量的值。</p><h3 id="_1-1-safty-liveness-fault-tolerance" tabindex="-1"><a class="header-anchor" href="#_1-1-safty-liveness-fault-tolerance" aria-hidden="true">#</a> 1.1 safty &amp; liveness &amp; fault tolerance</h3><ul><li>safty</li></ul><p>“坏”的事情永远不会发生</p><ul><li>liveness</li></ul><p>“好”的事情最终一定会发生</p><ul><li>fault tolerance</li></ul><p>容错，在分布式系统中允许节点失效。</p><p>FLP的结论就是在异步网络模型中不存在允许fault tolerance的既满足safty，又满足liveness的一致性算法。</p><h3 id="_1-2-consensus" tabindex="-1"><a class="header-anchor" href="#_1-2-consensus" aria-hidden="true">#</a> 1.2 consensus</h3><p>共识算法需要保证以下三个属性，共识算法首先是需要能够容错的。</p><ul><li>termination</li></ul><p>也就是达成共识的过程一定会结束，这对应着liveness特性</p><ul><li>agreenment</li></ul><p>所有的节点都同意一个提议，这对应着safty特性</p><ul><li>validity</li></ul><p>这个提议是来自其中一个节点的，这对应着safty特性。</p><p>从上面描述可以看出，consensus需要满足safty、liveness、fault tolerance三个特性，但是FLP定理又证明了在异步网络模型中不存在这样能够满足三个特性的一致性算法。那么我们所使用的paxos、raft为什么能够在允许少部分节点失效的场景下同时能够保证节点间的一致性呢？</p><h2 id="_2-paxos与flp" tabindex="-1"><a class="header-anchor" href="#_2-paxos与flp" aria-hidden="true">#</a> 2 paxos与FLP</h2><p>既然FLP证明了在异步网络模型中不存在可以满足safty和liveness的共识算法，而paxos又是当前分布式系统应用中最重要的共识算法，那么paxos是否违背了FLP呢？</p><p>首先作为分布式系统的共识算法，能够容忍存在节点失效是最基本的需求，safty是paxos必须要保证的，这里的safty对应consensus的agreenment和validity，paxos保证节点间达成一致的提议必定来自于某一个节点的提议，且所有节点都同意一个提议值。</p><p>paxos满足了safty和fault tolerance，结合FLP定理我们也能猜到paxos不能满足liveness特性，就是说在一些场景中会使得paxos一直得不到结果，这也就是paxos著名的“live lock”问题，具体场景后面会详细描述。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Paxos is always safe, and Paxos is very often live BUT not always.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">作者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1814300923@qq.com">Chenxuwkk</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/blog/study/page15.html" class="" aria-label="IMRD"><!--[--><!--]--> IMRD <!--[--><!--]--></a></span><span class="next"><a href="/blog/study/page18.html" class="" aria-label="STL"><!--[--><!--]--> STL <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.b33ca31f.js" defer></script>
  </body>
</html>
