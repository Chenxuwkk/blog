<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.48">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>嵌入式小记 | Chenxuwkk's Blog</title><meta name="description" content="Chenxuwkk's Blog">
    <link rel="modulepreload" href="/blog/assets/app.b33ca31f.js"><link rel="modulepreload" href="/blog/assets/page14.html.ad9dcffb.js"><link rel="modulepreload" href="/blog/assets/page14.html.810a54e6.js"><link rel="prefetch" href="/blog/assets/about.html.1a741a35.js"><link rel="prefetch" href="/blog/assets/contact.html.03aacf5e.js"><link rel="prefetch" href="/blog/assets/index.html.2e04d9b1.js"><link rel="prefetch" href="/blog/assets/index.html.dc88bf6f.js"><link rel="prefetch" href="/blog/assets/page01.html.6f1784f0.js"><link rel="prefetch" href="/blog/assets/index.html.b2e428a6.js"><link rel="prefetch" href="/blog/assets/page01.html.8647912c.js"><link rel="prefetch" href="/blog/assets/page02.html.2ae31539.js"><link rel="prefetch" href="/blog/assets/page03.html.e30663aa.js"><link rel="prefetch" href="/blog/assets/page04.html.5b5a177e.js"><link rel="prefetch" href="/blog/assets/page05.html.8dc876d3.js"><link rel="prefetch" href="/blog/assets/index.html.1faed378.js"><link rel="prefetch" href="/blog/assets/page00.html.397ec4cb.js"><link rel="prefetch" href="/blog/assets/page01.html.d4c49eb5.js"><link rel="prefetch" href="/blog/assets/page02.html.512e9f97.js"><link rel="prefetch" href="/blog/assets/page03.html.07c7a8d5.js"><link rel="prefetch" href="/blog/assets/page04.html.ea9d586c.js"><link rel="prefetch" href="/blog/assets/page05.html.c54831cd.js"><link rel="prefetch" href="/blog/assets/page06.html.130549e7.js"><link rel="prefetch" href="/blog/assets/page07.html.7c7f84ea.js"><link rel="prefetch" href="/blog/assets/page08.html.e3c59864.js"><link rel="prefetch" href="/blog/assets/page09.html.4785a4a4.js"><link rel="prefetch" href="/blog/assets/page10.html.c6168586.js"><link rel="prefetch" href="/blog/assets/page11.html.ce54a18d.js"><link rel="prefetch" href="/blog/assets/page12.html.1814d2d6.js"><link rel="prefetch" href="/blog/assets/page13.html.3976787d.js"><link rel="prefetch" href="/blog/assets/page15.html.3ad37cea.js"><link rel="prefetch" href="/blog/assets/page16.html.c8b15e87.js"><link rel="prefetch" href="/blog/assets/page17.html.bda23cdd.js"><link rel="prefetch" href="/blog/assets/page18.html.8e431832.js"><link rel="prefetch" href="/blog/assets/page19.html.4f7e6a54.js"><link rel="prefetch" href="/blog/assets/page20.html.53b884d3.js"><link rel="prefetch" href="/blog/assets/page21.html.ea7e75ec.js"><link rel="prefetch" href="/blog/assets/page22.html.6a8a8911.js"><link rel="prefetch" href="/blog/assets/page23.html.4da8711b.js"><link rel="prefetch" href="/blog/assets/page24.html.f15f76b8.js"><link rel="prefetch" href="/blog/assets/page25.html.47a43782.js"><link rel="prefetch" href="/blog/assets/index.html.09d3b996.js"><link rel="prefetch" href="/blog/assets/404.html.265028f6.js"><link rel="prefetch" href="/blog/assets/about.html.7c2de1fc.js"><link rel="prefetch" href="/blog/assets/contact.html.af265cd3.js"><link rel="prefetch" href="/blog/assets/index.html.494633a3.js"><link rel="prefetch" href="/blog/assets/index.html.6f6ef67c.js"><link rel="prefetch" href="/blog/assets/page01.html.24477c8b.js"><link rel="prefetch" href="/blog/assets/index.html.06f044c7.js"><link rel="prefetch" href="/blog/assets/page01.html.2c2c82ac.js"><link rel="prefetch" href="/blog/assets/page02.html.519c6760.js"><link rel="prefetch" href="/blog/assets/page03.html.9c782bee.js"><link rel="prefetch" href="/blog/assets/page04.html.01792834.js"><link rel="prefetch" href="/blog/assets/page05.html.ecd56c0e.js"><link rel="prefetch" href="/blog/assets/index.html.0d805a32.js"><link rel="prefetch" href="/blog/assets/page00.html.b5b8a137.js"><link rel="prefetch" href="/blog/assets/page01.html.196f31d8.js"><link rel="prefetch" href="/blog/assets/page02.html.446eff9c.js"><link rel="prefetch" href="/blog/assets/page03.html.265319dc.js"><link rel="prefetch" href="/blog/assets/page04.html.839ac225.js"><link rel="prefetch" href="/blog/assets/page05.html.3ba90d93.js"><link rel="prefetch" href="/blog/assets/page06.html.5ec3bc24.js"><link rel="prefetch" href="/blog/assets/page07.html.9811e105.js"><link rel="prefetch" href="/blog/assets/page08.html.550b989b.js"><link rel="prefetch" href="/blog/assets/page09.html.e59328fe.js"><link rel="prefetch" href="/blog/assets/page10.html.42d79a00.js"><link rel="prefetch" href="/blog/assets/page11.html.07064880.js"><link rel="prefetch" href="/blog/assets/page12.html.29d2532a.js"><link rel="prefetch" href="/blog/assets/page13.html.31c29b64.js"><link rel="prefetch" href="/blog/assets/page15.html.58f3b33b.js"><link rel="prefetch" href="/blog/assets/page16.html.8841620e.js"><link rel="prefetch" href="/blog/assets/page17.html.bc75eefa.js"><link rel="prefetch" href="/blog/assets/page18.html.467eb0c9.js"><link rel="prefetch" href="/blog/assets/page19.html.55cbf803.js"><link rel="prefetch" href="/blog/assets/page20.html.8b45092f.js"><link rel="prefetch" href="/blog/assets/page21.html.cc2b2ea3.js"><link rel="prefetch" href="/blog/assets/page22.html.d7349c76.js"><link rel="prefetch" href="/blog/assets/page23.html.e468a4f1.js"><link rel="prefetch" href="/blog/assets/page24.html.af7dd849.js"><link rel="prefetch" href="/blog/assets/page25.html.b0d918c5.js"><link rel="prefetch" href="/blog/assets/index.html.1b0cec2a.js"><link rel="prefetch" href="/blog/assets/404.html.b1b48cf0.js"><link rel="prefetch" href="/blog/assets/404.515c5f58.js"><link rel="prefetch" href="/blog/assets/Layout.14a38178.js"><link rel="prefetch" href="/blog/assets/auto.esm.36809f22.js"><link rel="prefetch" href="/blog/assets/index.daae04bf.js"><link rel="prefetch" href="/blog/assets/index.1842ee54.js"><link rel="prefetch" href="/blog/assets/mermaid.esm.min.ee1e0284.js">
    <link rel="stylesheet" href="/blog/assets/style.f6d73350.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><img class="logo" src="/blog/assets/img/logo.png" alt="Chenxuwkk&#39;s Blog"><span class="site-name can-hide">Chenxuwkk&#39;s Blog</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="导航"><span class="title">导航</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="导航"><span class="title">导航</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/blog/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/study/page01" class="" aria-label="学习记录"><!--[--><!--]--> 学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/question/page01" class="" aria-label="疑难问题"><!--[--><!--]--> 疑难问题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/manuscript/page01" class="" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/contact" class="" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/about/" class="" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Chenxuwkk" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="导航"><span class="title">导航</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="导航"><span class="title">导航</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/blog/guide/" class="" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/study/page01" class="" aria-label="学习记录"><!--[--><!--]--> 学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/question/page01" class="" aria-label="疑难问题"><!--[--><!--]--> 疑难问题 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/manuscript/page01" class="" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/contact" class="" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/blog/about/" class="" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/Chenxuwkk" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/blog/guide/" class="sidebar-item sidebar-heading" aria-label="指南"><!--[--><!--]--> 指南 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">学习记录 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/study/page01.html" class="sidebar-item" aria-label="Vuepress部署"><!--[--><!--]--> Vuepress部署 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page03.html" class="sidebar-item" aria-label="Linux 命令"><!--[--><!--]--> Linux 命令 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page02.html" class="sidebar-item" aria-label="C语言预处理"><!--[--><!--]--> C语言预处理 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page04.html" class="sidebar-item" aria-label="C语言位运算"><!--[--><!--]--> C语言位运算 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page05.html" class="sidebar-item" aria-label="C语言指针"><!--[--><!--]--> C语言指针 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page07.html" class="sidebar-item" aria-label="C语言动态内存"><!--[--><!--]--> C语言动态内存 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page08.html" class="sidebar-item" aria-label="C语言字符串处理"><!--[--><!--]--> C语言字符串处理 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page09.html" class="sidebar-item" aria-label="C语言结构体详解"><!--[--><!--]--> C语言结构体详解 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page10.html" class="sidebar-item" aria-label="C语言链表"><!--[--><!--]--> C语言链表 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page21.html" class="sidebar-item" aria-label="C++对C语言的加强"><!--[--><!--]--> C++对C语言的加强 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page06.html" class="sidebar-item" aria-label="Markdown高级技巧"><!--[--><!--]--> Markdown高级技巧 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page11.html" class="sidebar-item" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page12.html" class="sidebar-item" aria-label="C51"><!--[--><!--]--> C51 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page13.html" class="sidebar-item" aria-label="STM32"><!--[--><!--]--> STM32 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="嵌入式小记"><!--[--><!--]--> 嵌入式小记 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page14.html#spi和串口的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="SPI和串口的区别"><!--[--><!--]--> SPI和串口的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#bin文件和hex文件差异" class="router-link-active router-link-exact-active sidebar-item" aria-label="BIN文件和HEX文件差异"><!--[--><!--]--> BIN文件和HEX文件差异 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#sram-sdram-dram-rom-eprom-eeprom" class="router-link-active router-link-exact-active sidebar-item" aria-label="SRAM SDRAM DRAM ROM EPROM EEPROM"><!--[--><!--]--> SRAM SDRAM DRAM ROM EPROM EEPROM <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#amba" class="router-link-active router-link-exact-active sidebar-item" aria-label="AMBA"><!--[--><!--]--> AMBA <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#锁相环" class="router-link-active router-link-exact-active sidebar-item" aria-label="锁相环"><!--[--><!--]--> 锁相环 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#dma" class="router-link-active router-link-exact-active sidebar-item" aria-label="DMA"><!--[--><!--]--> DMA <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#c语言嵌入汇编" class="router-link-active router-link-exact-active sidebar-item" aria-label="C语言嵌入汇编"><!--[--><!--]--> C语言嵌入汇编 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#引脚和gpio" class="router-link-active router-link-exact-active sidebar-item" aria-label="引脚和GPIO"><!--[--><!--]--> 引脚和GPIO <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#fpga、zynq、pynq" class="router-link-active router-link-exact-active sidebar-item" aria-label="FPGA、ZYNQ、PYNQ"><!--[--><!--]--> FPGA、ZYNQ、PYNQ <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#开漏、推挽" class="router-link-active router-link-exact-active sidebar-item" aria-label="开漏、推挽"><!--[--><!--]--> 开漏、推挽 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#sbit" class="router-link-active router-link-exact-active sidebar-item" aria-label="Sbit"><!--[--><!--]--> Sbit <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#arm-、x86" class="router-link-active router-link-exact-active sidebar-item" aria-label="ARM 、x86"><!--[--><!--]--> ARM 、x86 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page14.html#复杂指令集和精简指令集" class="router-link-active router-link-exact-active sidebar-item" aria-label="复杂指令集和精简指令集"><!--[--><!--]--> 复杂指令集和精简指令集 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#arm架构图" class="router-link-active router-link-exact-active sidebar-item" aria-label="ARM架构图"><!--[--><!--]--> ARM架构图 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#x86架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="x86架构"><!--[--><!--]--> x86架构 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/study/page14.html#人工智能、机器学习、深度学习" class="router-link-active router-link-exact-active sidebar-item" aria-label="人工智能、机器学习、深度学习"><!--[--><!--]--> 人工智能、机器学习、深度学习 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#epoch-batch-size-和-iteration" class="router-link-active router-link-exact-active sidebar-item" aria-label="Epoch， Batch Size 和 Iteration"><!--[--><!--]--> Epoch， Batch Size 和 Iteration <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#stl" class="router-link-active router-link-exact-active sidebar-item" aria-label="STL"><!--[--><!--]--> STL <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#回溯和递归" class="router-link-active router-link-exact-active sidebar-item" aria-label="回溯和递归"><!--[--><!--]--> 回溯和递归 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/study/page14.html#一、概念" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、概念"><!--[--><!--]--> 一、概念 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#二、回溯和递归的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、回溯和递归的区别"><!--[--><!--]--> 二、回溯和递归的区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/study/page14.html#memcpy" class="router-link-active router-link-exact-active sidebar-item" aria-label="memcpy"><!--[--><!--]--> memcpy <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#注意力机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="注意力机制"><!--[--><!--]--> 注意力机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/study/page14.html#dropout" class="router-link-active router-link-exact-active sidebar-item" aria-label="Dropout"><!--[--><!--]--> Dropout <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/blog/study/page15.html" class="sidebar-item" aria-label="IMRD"><!--[--><!--]--> IMRD <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page17.html" class="sidebar-item" aria-label="Paxos算法"><!--[--><!--]--> Paxos算法 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page18.html" class="sidebar-item" aria-label="STL"><!--[--><!--]--> STL <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page19.html" class="sidebar-item" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page16.html" class="sidebar-item" aria-label="Leetcode"><!--[--><!--]--> Leetcode <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page20.html" class="sidebar-item" aria-label="剑指Offer"><!--[--><!--]--> 剑指Offer <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page22.html" class="sidebar-item" aria-label="剑指Offer II"><!--[--><!--]--> 剑指Offer II <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page23.html" class="sidebar-item" aria-label="二分专项"><!--[--><!--]--> 二分专项 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page24.html" class="sidebar-item" aria-label="动态规划专项"><!--[--><!--]--> 动态规划专项 <!--[--><!--]--></a><!----></li><li><a href="/blog/study/page25.html" class="sidebar-item" aria-label="SQL"><!--[--><!--]--> SQL <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">疑难问题 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/blog/question/page01.html" class="sidebar-item" aria-label="Git同步 😄"><!--[--><!--]--> Git同步 😄 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page02.html" class="sidebar-item" aria-label="Ubantu内存重新分配（Vmware） 🍎"><!--[--><!--]--> Ubantu内存重新分配（Vmware） 🍎 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page03.html" class="sidebar-item" aria-label="一个个小坑（Vue） 💢"><!--[--><!--]--> 一个个小坑（Vue） 💢 <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page04.html" class="sidebar-item" aria-label="VSCode编译C\C++"><!--[--><!--]--> VSCode编译C\C++ <!--[--><!--]--></a><!----></li><li><a href="/blog/question/page05.html" class="sidebar-item" aria-label="代码复现问题"><!--[--><!--]--> 代码复现问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/blog/manuscript/page01" class="sidebar-item sidebar-heading" aria-label="草稿本"><!--[--><!--]--> 草稿本 <!--[--><!--]--></a><!----></li><li><a href="/blog/contact" class="sidebar-item sidebar-heading collapsible" aria-label="联系本人"><!--[--><!--]--> 联系本人 <!--[--><!--]--></a><!----></li><li><a href="/blog/about" class="sidebar-item sidebar-heading" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="嵌入式小记" tabindex="-1"><a class="header-anchor" href="#嵌入式小记" aria-hidden="true">#</a> 嵌入式小记</h1><hr><nav class="table-of-contents"><ul><li><a aria-current="page" href="/blog/study/page14.html#spi和串口的区别" class="router-link-active router-link-exact-active">SPI和串口的区别</a></li><li><a aria-current="page" href="/blog/study/page14.html#bin文件和hex文件差异" class="router-link-active router-link-exact-active">BIN文件和HEX文件差异</a></li><li><a aria-current="page" href="/blog/study/page14.html#sram-sdram-dram-rom-eprom-eeprom" class="router-link-active router-link-exact-active">SRAM SDRAM DRAM ROM EPROM EEPROM</a></li><li><a aria-current="page" href="/blog/study/page14.html#amba" class="router-link-active router-link-exact-active">AMBA</a></li><li><a aria-current="page" href="/blog/study/page14.html#锁相环" class="router-link-active router-link-exact-active">锁相环</a></li><li><a aria-current="page" href="/blog/study/page14.html#dma" class="router-link-active router-link-exact-active">DMA</a></li><li><a aria-current="page" href="/blog/study/page14.html#c语言嵌入汇编" class="router-link-active router-link-exact-active">C语言嵌入汇编</a></li><li><a aria-current="page" href="/blog/study/page14.html#引脚和gpio" class="router-link-active router-link-exact-active">引脚和GPIO</a></li><li><a aria-current="page" href="/blog/study/page14.html#fpga、zynq、pynq" class="router-link-active router-link-exact-active">FPGA、ZYNQ、PYNQ</a></li><li><a aria-current="page" href="/blog/study/page14.html#开漏、推挽" class="router-link-active router-link-exact-active">开漏、推挽</a></li><li><a aria-current="page" href="/blog/study/page14.html#sbit" class="router-link-active router-link-exact-active">Sbit</a></li><li><a aria-current="page" href="/blog/study/page14.html#arm-、x86" class="router-link-active router-link-exact-active">ARM 、x86</a><ul><li><a aria-current="page" href="/blog/study/page14.html#复杂指令集和精简指令集" class="router-link-active router-link-exact-active">复杂指令集和精简指令集</a></li><li><a aria-current="page" href="/blog/study/page14.html#arm架构图" class="router-link-active router-link-exact-active">ARM架构图</a></li><li><a aria-current="page" href="/blog/study/page14.html#x86架构" class="router-link-active router-link-exact-active">x86架构</a></li></ul></li><li><a aria-current="page" href="/blog/study/page14.html#人工智能、机器学习、深度学习" class="router-link-active router-link-exact-active">人工智能、机器学习、深度学习</a></li><li><a aria-current="page" href="/blog/study/page14.html#epoch-batch-size-和-iteration" class="router-link-active router-link-exact-active">Epoch， Batch Size 和 Iteration</a></li><li><a aria-current="page" href="/blog/study/page14.html#stl" class="router-link-active router-link-exact-active">STL</a></li><li><a aria-current="page" href="/blog/study/page14.html#回溯和递归" class="router-link-active router-link-exact-active">回溯和递归</a><ul><li><a aria-current="page" href="/blog/study/page14.html#一、概念" class="router-link-active router-link-exact-active">一、概念</a></li><li><a aria-current="page" href="/blog/study/page14.html#二、回溯和递归的区别" class="router-link-active router-link-exact-active">二、回溯和递归的区别</a></li></ul></li><li><a aria-current="page" href="/blog/study/page14.html#memcpy" class="router-link-active router-link-exact-active">memcpy</a></li><li><a aria-current="page" href="/blog/study/page14.html#注意力机制" class="router-link-active router-link-exact-active">注意力机制</a></li><li><a aria-current="page" href="/blog/study/page14.html#dropout" class="router-link-active router-link-exact-active">Dropout</a></li></ul></nav><h2 id="spi和串口的区别" tabindex="-1"><a class="header-anchor" href="#spi和串口的区别" aria-hidden="true">#</a> SPI和串口的区别</h2><p>串口2条线的 一个<code>RX</code>一个<code>TX</code>， SPI是4线串口 分别是 <code>CS</code>(片选) <code>CLK</code>(时钟) <code>MISO</code>(数据输入)<code> MOSI</code>(数据输出)；</p><p>串口一般是一对一接收， <code>SPI</code>可以挂载多个<code>SPI</code>设备，通过<code>CS</code>选通设备。</p><p><code>SPI</code>(<code>Serial Peripheral Interface</code>--串行外设接口)总线系统是一种同步串行外设接口，它可以使<code>MCU</code>与各种外围设备以串行方式进行通信以交换信息。<code>SPI</code>有三个寄存器分别为：控制寄存器<code>SPCR</code>，状态寄存器<code>SPSR</code>，数据寄存器<code>SPDR</code>。外围设备包括<code>FLASHRAM</code>、网络控制器、<code>LCD</code>显示驱动器、<code>A/D</code>转换器和<code>MCU</code>等。<code>SPI</code>总线系统可直接与各个厂家生产的多种标准外围器件直接接口，该接口一般使用4条线：串行时钟线（<code>SCLK</code>）、主机输入/从机输出数据线<code>MISO</code>、主机输出/从机输入数据线<code>MOSI</code>和低电平有效的从机选择线<code>NSS</code>(有的<code>SPI</code>接口芯片带有中断信号线<code>INT</code>、有的<code>SPI</code>接口芯片没有主机输出/从机输入数据线<code>MOSI</code>)。 串行接口 (<code>Serial Interface</code>) 是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位的传送，按位顺序进行，最少只需一根传输线即可完成；成本低但传送速度慢。串行通讯的距离可以从几米到几千米；根据信息的传送方向，串行通讯可以进一步分为单工、半双工和全双工三种。</p><h2 id="bin文件和hex文件差异" tabindex="-1"><a class="header-anchor" href="#bin文件和hex文件差异" aria-hidden="true">#</a> BIN文件和HEX文件差异</h2><p><code>Hex</code>文件是以<code>ASCII</code>文本形式保存编译后的二进制文件信息。<code>Hex</code>文件使用<code>ASCII</code>文本的形式保存<code>Bin</code>文件的内容和<code>Bin</code>文件的一些配置信息。<code>Hex</code>文件可以由下载器（比如<code>jlink</code>）烧写到<code>MCU</code>的<code>ROM</code>中。</p><p><code>Bin</code>文件是<code>MCU</code>固件烧写的最终形式，也就是说<code>MCU</code>的<code>ROM</code>中烧写的内容完全就是<code>Bin</code>文件的内容。 <code>Hex</code>文件和<code>Bin</code>文件的存在价值</p><p>从上面的介绍中，我们发现<code>Hex</code>文件中每行的内容，就像我们发送串口数据的数据帧，并且最后一行还指示出文件结束了。我们得出<code>hex</code>文件的两个优点：</p><ol><li>使用<code>ASCII</code>文本保存固件信息，方便查看一些固件内容；</li><li>通过文件每行的校验和与最后一行的文件结束标志，在文件的传输与保存过程中能够发现固件是否完整。</li></ol><p><code>Hex</code>文件有更好的可读性，最重要的是<code>hex</code>文件能够保证固件在保存与传输时的完整性。因此<code>hex</code>文件更适用于保存与传输。而<code>Bin</code>文件是纯二进制文件，内部只包含程序编译后的机器码和变量数据。当文件损坏时，我们也无法知道文件已损坏。不过<code>Bin</code>文件作为固件的最终形式，在使用串口下载程序或者远程升级时，是不可替代的。</p><p>引用来源：<a href="https://blog.csdn.net/duhui75/article/details/121735992" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/duhui75/article/details/121735992<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="sram-sdram-dram-rom-eprom-eeprom" tabindex="-1"><a class="header-anchor" href="#sram-sdram-dram-rom-eprom-eeprom" aria-hidden="true">#</a> SRAM SDRAM DRAM ROM EPROM EEPROM</h2><p><strong>SRAM :</strong> 静态RAM，不用刷新，速度可以非常快，像CPU内部的cache，都是静态RAM，缺点是一个内存单元需要的晶体管数量多，因而价格昂贵，容量不大。</p><p>什么是SRAM SRAM 的英文全称是&#39;Static RAM&#39;，翻译成中文就是&#39;静态随机存储器&#39;。SRAM主要用于制造Cache。</p><p>SRAM，静态的随机存取存储器，加电情况下，不需要刷新，数据不会丢失，而且，一般不是行列地址复用的。</p><p><strong>SDRAM：</strong> 同步动态RAM，需要刷新，速度较快，容量大。</p><p>SDRAM 的英文全称是&#39;Synchronous DRAM&#39;，翻译成中文就是&#39;扩充数据输出内存&#39;，它比一般DRAM和EDO RAM速度都快，它已经逐渐成为PC机的标准内存配置。</p><p>SDRAM，同步的DRAM，即数据的读写需要时钟来同步。</p><p><strong>DRAM：</strong> 动态RAM，需要刷新，容量大。</p><p>DRAM 的英文全称是&#39;Dynamic RAM&#39;，翻译成中文就是&#39;动态随机存储器&#39;。DRAM用于通常的数据存取。我们常说内存有多大，主要是指DRAM的容量。</p><p>DRAM，动态随机存取存储器，需要不断的刷新，才能保存数据。 而且是行列地址复用的，许多都有页模式。</p><p>主要是存储单元结构不同导致了容量的不同。一个DRAM存储单元大约需要一个晶体管和一个电容（不包括行读出放大器等），而一个SRAM存储单元大约需要六个晶体管。DRAM和SDRAM由于实现工艺问题，容量较SRAM大，但是读写速度不如SRAM。 一个是静态的，一个是动态的，静态的是用的双稳态触发器来保存信息，而动态的是用电子，要不时的刷新来保持。 内存（即随机存贮器RAM）可分为静态随机存储器SRAM，和动态随机存储器DRAM两种。我们经常说的“内存”是指DRAM。而SRAM大家却接触的很少</p><p><strong>ROM:</strong> 只读存储器（Read-Only Memory，ROM）以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。ROM所存数据稳定 ，断电后所存数据也不会改变，并且结构较简单，使用方便，因而常用于存储各种固定程序和数据。</p><p><strong>EPROM：</strong></p><p>EPROM的特点：EPROM的编程需要使用编程器完成。编程器是用于产生EPROM编程所需要的高压脉冲信号的装置。编程时将EPROM的数据送到随机存储器中，然后启动编程程序，编程器便将数据逐行地写入EPROM中。</p><p>一片编程后的EPROM，可以保持其数据大约10～20年，并能无限次读取。擦除窗口必须保持覆盖，以防偶然被阳光擦除。老式电脑的BIOS芯片，一般都是EPROM，擦除窗口往往被印有BIOS发行商名称、版本和版权声明的标签所覆盖。EPROM已经被EEPROM取代（电擦除只读寄存器）。</p><p><strong>EEPROM：</strong></p><p>EEPROM是指带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。 EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。</p><p>EEPROM的特点：EEPROM一般用于即插即用（Plug &amp; Play）；常用在接口卡中，用来存放硬件设置数据；也常用在防止软件非法拷贝的“硬件锁”上面。</p><p>EEPROM的基本原理：由于EPROM操作的不便，后来出的主板上BIOS ROM芯片大部分都采用EEPROM。EEPROM的擦除不需要借助于其它设备，它是以电子信号来修改其内容的，而且是以Byte为最小修改单位，不必将资料全部洗掉才能写入，彻底摆脱了EPROM Eraser和编程器的束缚。</p><p>引用来源：<a href="https://blog.csdn.net/qq_38531460/article/details/106625533" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_38531460/article/details/106625533<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="amba" tabindex="-1"><a class="header-anchor" href="#amba" aria-hidden="true">#</a> AMBA</h2><p><strong>AMBA (Advanced Microcontroller Bus Archite高级处理器总线架构</strong></p><ul><li>AHB (Advanced High-perf Bus) 高级高性能总线</li><li>ASB (Advanced System Bus) 高级系统总线</li><li>APB (Advanced Peripheral Bus) 高级外围总线</li><li>AXI (Advanced eXtensible Interface) 高级可拓展接口</li></ul><p>这些内容加起来就定义出一套为了高性能SoC而设计的片上通信的标准。</p><ul><li>AHB主要是针对高效率、高频宽及快速系统模块所设计的总线，它可以连接如微处理器、芯片上或芯片外的内存模块和DMA等高效率模块。</li><li>APB主要用在低速且低功率的外围，可针对外围设备作功率消耗及复杂接口的最佳化。APB在AHB和低带宽的外围设备之间提供了通信的桥梁，所以APB是AHB或ASB的二级拓展总线。</li><li>AXI：高速度、高带宽，管道化互联，单向通道，只需要首地址，读写并行，支持乱序，支持非对齐操作，有效支持初始延迟较高的外设，连线非常多。</li><li>AHB主要用于<strong>高性能模块</strong>(如CPU、DMA和DSP等)之间的连接，作为SoC的片上系统总线，它包括以下一些特性：单个时钟边沿操作;非三态的实现方式;支持突发传输;支持分段传输;支持多个主控制器;可配置32位&quot;128位总线宽度;支持字节、半字节和字的传输。</li><li>APB主要用于<strong>低带宽</strong>的周边外设之间的连接，例如UART、1284等，它的总线架构不像AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。其特性包括：两个时钟周期传输;无需等待周期和回应信号;控制逻辑简单，只有四个控制信号。</li></ul><p>引用来源1：<a href="http://design.eccn.com/design_2017112310063415.htm" target="_blank" rel="noopener noreferrer">http://design.eccn.com/design_2017112310063415.htm<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>引用来源2：<a href="https://www.elecfans.com/emb/jiekou/20171115579661.html" target="_blank" rel="noopener noreferrer">https://www.elecfans.com/emb/jiekou/20171115579661.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="锁相环" tabindex="-1"><a class="header-anchor" href="#锁相环" aria-hidden="true">#</a> 锁相环</h2><p><code>PLL(Phase Locked Loop)</code>：为锁相回路或锁相环，用来统一整合时钟信号，使高频器件正常工作，如内存的存取资料等。PLL用于振荡器中的反馈技术。 许多电子设备要正常工作，通常需要外部的输入信号与内部的振荡信号同步。一般的晶振由于工艺与成本原因，做不到很高的频率，而在需要高频应用时，由相应的器件VCO，实现转成高频，但并不稳定，故利用锁相环路就可以实现稳定且高频的时钟信号。</p><p>锁相环路是一种反馈控制电路，简称锁相环<code>（PLL,Phase-Locked Loop）</code>。锁相环的特点是：利用外部输入的参考信号控制环路内部振荡信号的频率和相位。因锁相环可以实现输出信号频率对输入信号频率的自动跟踪，所以锁相环通常用于闭环跟踪电路。锁相环在工作的过程中，当输出信号的频率与输入信号的频率相等时，输出电压与输入电压保持固定的相位差值，即输出电压与输入电压的相位被锁住，这就是锁相环名称的由来。</p><h2 id="dma" tabindex="-1"><a class="header-anchor" href="#dma" aria-hidden="true">#</a> DMA</h2><p>DMA（Direct Memory Access，直接内存存取）它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。</p><p>DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工作。DMA 传输对于高效能 嵌入式系统算法和网络是很重要的。</p><h2 id="c语言嵌入汇编" tabindex="-1"><a class="header-anchor" href="#c语言嵌入汇编" aria-hidden="true">#</a> C语言嵌入汇编</h2><p><strong>第一种</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token keyword">asm</span></span></span>
	MOV R7，#<span class="token number">7</span>
	<span class="token comment">/*
    */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragna</span> <span class="token expression">endasm</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二种</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//xxx.s</span>
<span class="token operator">?</span>PR<span class="token operator">?</span>fun_test<span class="token operator">?</span>test_asm SEGMENT CODE
PUBLIC 	fun_test
fun_test<span class="token operator">:</span>
	nop
    ret
 end 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">fun_test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
    
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">fun_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第三种</strong></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token class-name">uint32_t</span> csr_addrh <span class="token operator">=</span> csr_addr<span class="token operator">&gt;&gt;</span><span class="token number">32</span><span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> csr_addrl <span class="token operator">=</span> csr_addr<span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> tmp1<span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> tmp2<span class="token punctuation">;</span>

<span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;.set push\n&quot;</span>
    <span class="token string">&quot;.set mips64\n&quot;</span>
    <span class="token string">&quot;dsll %[tmp1], %[csrh], 32\n&quot;</span>
    <span class="token string">&quot;dsll %[tmp2], %[csrl], 32\n&quot;</span>
    <span class="token string">&quot;dsrl %[tmp2], %[tmp2], 32\n&quot;</span>
    <span class="token string">&quot;or %[tmp1], %[tmp1], %[tmp2]\n&quot;</span>
    <span class="token string">&quot;sd %[val], 0(%[tmp1])\n&quot;</span>
    <span class="token string">&quot;.set pop\n&quot;</span>
    <span class="token operator">:</span> <span class="token punctuation">[</span>tmp1<span class="token punctuation">]</span> <span class="token string">&quot;=&amp;r&quot;</span> <span class="token punctuation">(</span>tmp1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>tmp2<span class="token punctuation">]</span> <span class="token string">&quot;=&amp;r&quot;</span> <span class="token punctuation">(</span>tmp2<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>csrh<span class="token punctuation">]</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>csr_addrh<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>csrl<span class="token punctuation">]</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>csr_addrl<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>asm volatile(&quot;InSTructiON List&quot; : Output : Input : Clobber/Modify);</code><code>asm</code>是关键字，必选项 <code>volatile</code> 是可选的，加了，<code>GCC</code>就不会优化这句。 汇编指令间必须被双引号括起来; 汇编指令间必须使用&quot;<code>;</code>&quot;、&quot;<code>/n</code>&quot;或&quot;<code>/n/t</code>&quot;分开分开; <code>()</code>内的是可选的，如<code>asm volatile(&quot;&quot;)</code>是可以的，只是无意义 仅省动其中一项，分号需要加上: 如这个省了输入和输出的，<code>asm volatile (&quot;sync&quot; : : :&quot;memory&quot;)</code><code>Clobber/Modify</code>表示特定的关键字，让汇编做相应的动作</p><p><strong>示例一</strong></p><p>接口参数汇编中用0% ，1%这种来表示 占位符引用C语言变量，操作数占位符最多10 个，名称如下：%0，%1，...，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节）,在%和序号之间插入一个字母，&quot;b&quot;代表低字节，&quot;h&quot;代表高字节，例如：%h0</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>
<span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">&quot;lhbrx %0,0,%1&quot;</span>
<span class="token operator">:</span> <span class="token string">&quot;=r&quot;</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token operator">:</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span> <span class="token punctuation">(</span><span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token comment">//0% 表示第一个参数, 1%这种数字表示第二个参数，依次类推</span>
<span class="token comment">//0%对应输入参数val, 1%对应输出参数:addr， 需要数位置，且容易搞混。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="引脚和gpio" tabindex="-1"><a class="header-anchor" href="#引脚和gpio" aria-hidden="true">#</a> 引脚和GPIO</h2><p>引脚指芯片硬件引脚</p><p><code>GPIO</code>是一种输入输出外设</p><h2 id="fpga、zynq、pynq" tabindex="-1"><a class="header-anchor" href="#fpga、zynq、pynq" aria-hidden="true">#</a> FPGA、ZYNQ、PYNQ</h2><p>FPGA（Field Programmable Gate Array）现场可编程逻辑门阵列</p><p>ZYNQ = FPGA + ARM</p><p>PYNQ = Python + ZYNQ</p><h2 id="开漏、推挽" tabindex="-1"><a class="header-anchor" href="#开漏、推挽" aria-hidden="true">#</a> 开漏、推挽</h2><p>开漏（外部上拉电阻才可输出高）可以线与（有0都为0）、可以将3.3v 外接上拉电源输出5v电压，多用于I2C和SMBUS总线。</p><p>推挽可以直接输出高低电平，优点开关效率效率高，电流大，驱动能力强。</p><h2 id="sbit" tabindex="-1"><a class="header-anchor" href="#sbit" aria-hidden="true">#</a> Sbit</h2><p><code>sbit</code>并不是指定义特殊功能寄存器的变量。它的意义跟特殊功能寄存器一点关系都没有。这是一个常见的误区。</p><p><code>sbit</code>关键字严格来说也不算“变量类型”，而属于“位声明”。</p><p><code>sbit</code>是指可位寻址变量其中的某一位。至于这个“可位寻址的变量”究竟是不是寄存器，没有任何关系。换句话说，就算一个普通的变量，只要定义在位寻址区，那它也是可以用<code>sbit</code>声明各的。</p><p>51内部<code>RAM</code>的<code>data</code>段，地址<code>20H</code>~<code>2FH</code>有一个长度为16字节的位寻址区，称为<code>bdata</code>段，把普通变量定义在这个位置就能用<code>sbit</code>声明各位，比如：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>uchar bdata x<span class="token punctuation">;</span> <span class="token comment">//普通变量</span>
sbit x0 <span class="token operator">=</span> x<span class="token operator">^</span><span class="token number">0</span><span class="token punctuation">;</span>
…
sbit x7 <span class="token operator">=</span> x<span class="token operator">^</span><span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样也是可以的。反过来，一个寄存器变量，只要不是定义在位寻址区，那就不能用sbit声明各位。</p><p>我们知道，在51上，地址为8整数倍的特殊功能寄存器才能进行位寻址，像<code>P0</code>、<code>P1</code>这些就可以，其它的寄存器是不能位寻址的，也就没法用<code>sbit</code>。所以说<code>sbit</code>跟寄存器根本没有必然联系，它与“能否进行位寻址”才是绝对相关的。</p><h2 id="arm-、x86" tabindex="-1"><a class="header-anchor" href="#arm-、x86" aria-hidden="true">#</a> ARM 、x86</h2><h3 id="复杂指令集和精简指令集" tabindex="-1"><a class="header-anchor" href="#复杂指令集和精简指令集" aria-hidden="true">#</a> 复杂指令集和精简指令集</h3><p>从CPU发明到现在，有非常多种架构，从我们熟悉的X86，ARM，到不太熟悉的MIPS，IA64，它们之间的差距都非常大。但是如果从最基本的逻辑角度来分类的话，它们可以被分为两大类，即所谓的“复杂指令集”与“精简指令集”系统，也就是经常看到的“CISC”与“RISC”。 Intel和ARM处理器的第一个区别是，前者使用<strong>复杂指令集</strong>（CISC)，而后者使用精简指令集（RISC）。属于这两种类中的各种架构之间最大的区别，在于它们的设计者考虑问题方式的不同。</p><p>引用来源：<a href="https://blog.csdn.net/u013171226/article/details/119597528" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u013171226/article/details/119597528<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="arm架构图" tabindex="-1"><a class="header-anchor" href="#arm架构图" aria-hidden="true">#</a> <strong>ARM架构图</strong></h3><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&amp;TImes;8位乘法器、32&amp;TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据/地址寄存器组成.</p><ol><li>ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</li><li>桶形移位寄存器：ARM采用了32位的桶形移位寄存器，这样可以使在左移/右移n位、环移n位和算术右移n位等都可以一次完成。</li><li>高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&amp;TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1/3）。</li><li>浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</li><li>控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</li><li>寄存器</li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/167860/26/25002/20371/6298a2f9E7ad353d4/5b17701da5c9e9a3.jpg" alt="o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><h3 id="x86架构" tabindex="-1"><a class="header-anchor" href="#x86架构" aria-hidden="true">#</a> <strong>x86架构</strong></h3><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><ol><li>CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</li><li>北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</li><li>南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线。</li><li>内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</li><li>显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</li><li>显示j接口</li><li>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</li><li>声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</li><li>SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</li><li>硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</li><li>总线</li></ol><p><img src="https://m.360buyimg.com/babel/jfs/t1/205701/1/23303/23309/6298a2d8E81384aed/8a2d5362c222e7e6.jpg" alt="pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>引用来源：<a href="https://blog.csdn.net/bleauchat/article/details/90114342" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/bleauchat/article/details/90114342<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="人工智能、机器学习、深度学习" tabindex="-1"><a class="header-anchor" href="#人工智能、机器学习、深度学习" aria-hidden="true">#</a> 人工智能、机器学习、深度学习</h2><p>基于“训练”海量数据得到的模型算法来解决特定问题的方法，我们称之为机器学习。传统的机器学习算法在某些场景，例如：指纹、人脸识别等领域的应用已能达到商业化标准，但其“智能”很有限、或者说“先验”离不开领域专家的介入，直到深度学习算法的出现。</p><p>深度学习作为机器学习的子类，它又是如何工作的呢？我们还是以人脸识别为例。传统的机器学习在确定了相应的“面部特征”，例如：眼睛、鼻子、嘴等之后，才能基于这些特征做进一步的分类处理；而深度学习通过多层神经网络结构，将底层属性逐步“进化成”人能看懂理解的高层属性，从而实现自动找出分类问题所需要的重要特征。这一点是两者最根本的区别所在。</p><p>人工智能、机器学习、和深度学习的包含关系，以及各自兴起、得到突破、和大发展的时间段如下图所示。可以看出，机器学习是实现人工智能的一种技术方法，而深度学习是机器学习这门技术的子集。</p><p><img src="https://m.360buyimg.com/babel/jfs/t1/182544/18/25653/28765/6298a315E29ee0312/b2a154cafc7fce66.jpg" alt="7acb0a46f21fbe09f8599855606d35398744ad07.jpeg"></p><p>那机器学习和深度学习具体有哪些维度的不同呢？</p><p>**1. 数据依赖：**深度学习必需大数据量，当数据量较小时，深度学习不合适；</p><p>**2. 硬件依赖：**为保证算力，深度学习非常依赖于高端硬件设施，通常都要求有GPU环境参与运算；</p><p>**3. 特征工程：**这一点上面已经提过，这是两者最根本的区别所在；</p><p>**4. 解决方案：**机器学习类似于分治法，而深度学习则是一步到位、提供端到端的实时解决方案，虽然其模型训练的时长通常高于机器学习。</p><p>深度学习本来并不是一种独立的学习方法，其本身也会用到有监督和无监督的学习方法来训练深度神经网络。但由于近几年该领域发展迅猛，一些特有的学习手段相继被提出（如残差网络），因此越来越多的人将其单独看作一种学习的方法。 最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并不是一个全新的概念，可大致理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法和激活函数等方面做出相应的调整。其实有不少想法早年间也曾有过，但由于当时训练数据量不足、计算能力落后，因此最终的效果不尽如人意。 深度学习摧枯拉朽般地实现了各种任务，使得似乎所有的机器辅助功能都变为可能。无人驾驶汽车，预防性医疗保健，甚至是更好的电影推荐，都近在眼前，或者即将实现。</p><p><img src="https://m.360buyimg.com/babel/jfs/t1/193773/5/25404/17872/6298a33dE4e7d320a/e7dc42b684ccc8ff.jpg" alt="20210125110123942.jpg"></p><p>目前，业界有一种错误的较为普遍的意识，即“深度学习最终可能会淘汰掉其他所有机器学习算法”。这种意识的产生主要是因为，当下深度学习在计算机视觉、自然语言处理领域的应用远超过传统的机器学习方法，并且媒体对深度学习进行了大肆夸大的报道。深度学习，作为目前最热的机器学习方法，但并不意味着是机器学习的终点。起码目前存在以下问题：</p><ol><li>深度学习模型需要大量的训练数据，才能展现出神奇的效果，但现实生活中往往会遇到小样本问题，此时深度学习方法无法入手，传统的机器学习方法就可以处理；</li><li>有些领域，采用传统的简单的机器学习方法，可以很好地解决了，没必要非得用复杂的深度学习方法；</li><li>深度学习的思想，来源于人脑的启发，但绝不是人脑的模拟，举个例子，给一个三四岁的小孩看一辆自行车之后，再见到哪怕外观完全不同的自行车，小孩也十有八九能做出那是一辆自行车的判断，也就是说，人类的学习过程往往不需要大规模的训练数据，而现在的深度学习方法显然不是对人脑的模拟。深度学习大佬 Yoshua Bengio 在 Quora 上回答一个类似的问题时，有一段话讲得特别好，这里引用一下，以回答上述问题：</li></ol><div class="custom-container tip"><p class="custom-container-title">提示</p><p>Science is NOT a battle, it is a collaboration. We all build on each other’s ideas. Science is an act of love, not war. Love for the beauty in the world that surrounds us and love to share and build something together. That makes science a highly satisfying activity, emotionally speaking!</p></div><p>这段话的大致意思是，科学不是战争而是合作，任何学科的发展从来都不是一条路走到黑，而是同行之间互相学习、互相借鉴、博采众长、相得益彰，站在巨人的肩膀上不断前行。机器学习的研究也是一样，你死我活那是邪教，开放包容才是正道。结合机器学习2000年以来的发展，再来看Bengio的这段话，深有感触。进入21世纪，纵观机器学习发展历程，研究热点可以简单总结为2000-2006年的流形学习、2006年-2011年的稀疏学习、2012年至今的深度学习。未来哪种机器学习算法会成为热点呢？深度学习三大巨头之一吴恩达曾表示，“在继深度学习之后，迁移学习将引领下一波机器学习技术”。</p><h2 id="epoch-batch-size-和-iteration" tabindex="-1"><a class="header-anchor" href="#epoch-batch-size-和-iteration" aria-hidden="true">#</a> Epoch， Batch Size 和 Iteration</h2><p>举个例子：将10kg的面粉使用面条加工机(每次只能处理2kg)，加工成10kg的面条。首先得把10kg面粉分成5份2kg的面粉，然后放入机器加工，经过5次，可以将这10kg面粉首次加工成面条，但是现在的面条肯定不好吃，因为不劲道，于是把10kg面条又放进机器再加工一遍，还是每次只处理2kg，处理5次，现在感觉还行，但是不够完美；于是又重复了一遍：将10kg上次加工好的面条又放进机器，每次2kg，加工5次，最终成型了，完美了，结束了。那么到底重复加工几次呢？只有有经验的师傅才知道。</p><p>这就形象地说明：Epoch就是10斤面粉被加工的次数（上面的3次）；Batch Size就是每份的数量（上面的2kg），Iteration就是将10kg面粉加工完一次所使用的循环次数（上面的5次）。显然 1个epoch = BatchSize * Iteration</p><h2 id="stl" tabindex="-1"><a class="header-anchor" href="#stl" aria-hidden="true">#</a> STL</h2><p>c++标准模板库</p><p>https://blog.csdn.net/qq_50285142/article/details/114026148</p><h2 id="回溯和递归" tabindex="-1"><a class="header-anchor" href="#回溯和递归" aria-hidden="true">#</a> 回溯和递归</h2><h3 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念" aria-hidden="true">#</a> 一、概念</h3><p>递归：程序调用自身的编程技巧称为递归（ recursion）。 回溯：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><h3 id="二、回溯和递归的区别" tabindex="-1"><a class="header-anchor" href="#二、回溯和递归的区别" aria-hidden="true">#</a> 二、回溯和递归的区别</h3><p>递归是一种算法结构，递归会出现在子程序中，形式上表现为直接或间接的自己调用自己；而回溯是一种算法思想，它是用递归实现的，回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。 举个通俗的例子就是： 我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。 如果我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。 这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。</p><p>其实回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong></p><h2 id="memcpy" tabindex="-1"><a class="header-anchor" href="#memcpy" aria-hidden="true">#</a> memcpy</h2><p>https://www.runoob.com/cprogramming/c-function-memcpy.html</p><h2 id="注意力机制" tabindex="-1"><a class="header-anchor" href="#注意力机制" aria-hidden="true">#</a> <strong>注意力机制</strong></h2><p>神经网络中的注意力机制（Attention Mechanism）是在计算能力有限的情况下，将计算资源分配给更重要的任务，同时解决信息超载问题的一种资源分配方案。在神经网络学习中，一般而言模型的参数越多则模型的表达能力越强，模型所存储的信息量也越大，但这会带来信息过载的问题。那么通过引入注意力机制，在众多的输入信息中聚焦于对当前任务更为关键的信息，降低对其他信息的关注度，甚至过滤掉无关信息，就可以解决信息过载问题，并提高任务处理的效率和准确性。</p><p>这就类似于人类的视觉注意力机制，通过扫描全局图像，获取需要重点关注的目标区域，而后对这一区域投入更多的注意力资源，获取更多与目标有关的细节信息，而忽视其他无关信息。通过这种机制可以利用有限的注意力资源从大量信息中快速筛选出高价值的信息。</p><h2 id="dropout" tabindex="-1"><a class="header-anchor" href="#dropout" aria-hidden="true">#</a> Dropout</h2><p>Dropout训练是由Hinton等人提出的，是作为一种通过在训练过程中每次迭代地随机移除特征子集来控制过拟合的方法。虽然dropout已经被证明是一种非常成功的技术，但其成功的原因在理论层面上还没有得到很好的理解。但dropout可以看作是一种集成方法。当单个模型的体系结构彼此不同时，多个模型的组合是最有帮助的。</p><p>Dropout也有许多变种。有学者提出了DropConnect，作为dropout的一个推广，其中每个连接（而不是每个输出单元）都可以随机移除。研究表明，Dropout也适用于RNN，这些工作可以对递归的连接应用dropout。值得注意的是，目前的dropout技术及其变种都只是直接应用于神经网络，没有一个明确的结论能解释他们对图数据的影响。另一方面，本文提出了理论分析来解释本文在输入图上使用的双重dropout。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">作者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1814300923@qq.com">Chenxuwkk</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/blog/study/page13.html" class="" aria-label="STM32"><!--[--><!--]--> STM32 <!--[--><!--]--></a></span><span class="next"><a href="/blog/study/page15.html" class="" aria-label="IMRD"><!--[--><!--]--> IMRD <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.b33ca31f.js" defer></script>
  </body>
</html>
